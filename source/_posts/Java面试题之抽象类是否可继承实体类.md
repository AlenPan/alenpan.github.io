---
title: Java面试题解析（1）
layout: post
subtitle: 抽象类是否可继承实体类
date: 2017-01-05 17:33:47
tags: 
- Java
- Class
- Article
- 面试
---

## 抽象类是否可继承实体类(concrete class)？

网上的找到的面试题答案是：

> 抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。

答案很明确，可以继承。

其实从`Object`就是个实体类，`java`的API文档里，每个抽象类的条目里都明确写着直接或间接继承自`Object`，所以这点是没有疑问的。

关键在于这答案里所说的**“前提是实体类必须有明确的构造函数”**一句，是什么意思？



## 问题解析

一般学习者会写的简单试验代码：

```java
class A{}

abstract class B extends A{} 
```

结果完全正常，编译通过。似乎和**“实体类必须有明确的构造函数”**没有关系。

这个问题涉及到两个个基础知识：

> 1. **所有的class都必须有一个构造方法（这里需要注意的是，抽象类也是拥有构造方法的，但抽象类与接口一样是不能创建实例的）**，如果你没有在代码里声明构造方法，系统会自动给你生成一个公有无参的构造方法。而只要你自己声明了一个构造方法，无论有参无参，私有公有，系统就不再帮你生成默认无参构造器了。
> 2. 所有的子类构造器都要求在第一行代码中调用父类构造器，如果不写，系统默认去调用父类的无参构造器。

 

所以，如果把系统默认配给的方法也算进去，`class A`的代码实际上是

```java
class A{
	public A(){}
} 
```

B继承A的时候，则是

```java
abstract class B extends A{
    public B(){
      super();
    }
} 
```

要试验出这继承规则的内部情况，也很简单，在最上面那个简单试验代码里，加上个私有构造器，有参无参都行。

```java
class A{
  	private A(){} 
}
```

这个时候，如基础知识(1) 中所说，系统不再给你默认无参构造器，B的构造器根据(2)中的规则去调用`super()`，却找不到A的无参构造器，所以导致`abstract class B extends A{}` 编译不能通过。（因为A中没有任何构造器可供子类调用，其实这个时候A只能够供内部类继承。）



## 总结

现在，你应该了解了资料给的那句语焉不详的**“实体类必须有明确的构造函数”**的含义：

1. 没写构造器的，那是拥有默认无参公有构造函数的，子类可以什么都不写，让默认构造器去调用它。这是最初那两行代码的情况。
2. 写了子类可访问的无参构造器的，也是一样，子类里可以什么都不写，用默认机制调用。
3. 写了有参构造器却没写无参构造器的，父类里没有子类可访问的无参构造器，子类必须在子类构造器里的第一句写明，调用父类有参构造器，并把参数传进去。
4. 声明为`final`的类或者所有构造器都不在子类访问权限之内的类无法继承。



其实只要是在类的继承中，无论抽象还是实体，都需要符合这个规则的。在这个继承试验中随时删掉或是加上`abstract`的前缀，结果都没有变化。个人觉得**“实体类必须有明确的构造函数”**一句实在是无法把这个情况表达清楚，所以广大求职者还是写得清楚些好。



我喜欢的写法是“**可以继承，但是和实体类的继承一样，也要求父类可继承，并且拥有子类可访问到的构造器。**” 



转载自：http://blog.csdn.net/ckw1988/article/details/4639514