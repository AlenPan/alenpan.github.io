<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlenPan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://alenpan.github.io/"/>
  <updated>2017-02-08T08:50:21.219Z</updated>
  <id>http://alenpan.github.io/</id>
  
  <author>
    <name>Alen Pan</name>
    <email>a1459578959@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AndroidStudio快捷键汇总</title>
    <link href="http://alenpan.github.io/2017/01/21/AndroidStudio%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/"/>
    <id>http://alenpan.github.io/2017/01/21/AndroidStudio快捷键汇总/</id>
    <published>2017-01-21T04:18:36.000Z</published>
    <updated>2017-02-08T08:50:21.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始全面转向Android Studio开发了，经常要去查快捷键，索性汇总下，自己方便查找</p>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>F1</td>
<td>帮助</td>
</tr>
<tr>
<td>Alt(Option)+F1</td>
<td>查找文件所在目录位置</td>
</tr>
<tr>
<td>Alt(Option)+1</td>
<td>快速打开或隐藏工程面板</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+</td>
<td>打开设置对话框</td>
</tr>
<tr>
<td>Alt(Option)+Home</td>
<td>跳转到导航栏</td>
</tr>
<tr>
<td>Esc</td>
<td>光标返回编辑框</td>
</tr>
<tr>
<td>Shift+Esc</td>
<td>光标返回编辑框,关闭无用的窗口</td>
</tr>
<tr>
<td>Shift+Click</td>
<td>关闭标签页</td>
</tr>
<tr>
<td>F12</td>
<td>把焦点从编辑器移到最近使用的工具窗口</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Y</td>
<td>同步</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+S</td>
<td>打开设置对话框</td>
</tr>
<tr>
<td>Alt(Option)+Shift+Inert</td>
<td>开启/关闭列选择模式</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Shift+S</td>
<td>打开当前项目/模块属性</td>
</tr>
<tr>
<td>Alt(Option)+Shift+C</td>
<td>查看文件的变更历史</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+F10</td>
<td>运行</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+F9</td>
<td>debug运行</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+F12</td>
<td>资源管理器打开文件夹</td>
</tr>
</tbody>
</table>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl(Command)+C</td>
<td>复制当前行或选中的内容</td>
</tr>
<tr>
<td>Ctrl(Command)+D</td>
<td>粘贴当前行或选中的内容</td>
</tr>
<tr>
<td>Ctrl(Command)+X</td>
<td>剪切当前行或选中的内容</td>
</tr>
<tr>
<td>Ctrl(Command)+Y</td>
<td>删除行</td>
</tr>
<tr>
<td>Ctrl(Command)+Z</td>
<td>倒退</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Z</td>
<td>向前</td>
</tr>
<tr>
<td>Alt(Option)+Enter</td>
<td>自动修正</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+I</td>
<td>将选中的代码进行自动缩进编排</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+O</td>
<td>优化导入的类和包</td>
</tr>
<tr>
<td>Alt(Option)+Insert</td>
<td>得到一些Intention Action，可以生成构造器、Getter、Setter、将 <code>==</code> 改为 <code>equals()</code> 等</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+V</td>
<td>选最近使用的剪贴板内容并插入</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Shift+V</td>
<td>简单粘贴</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Insert</td>
<td>选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V）</td>
</tr>
<tr>
<td>Ctrl(Command)+Enter</td>
<td>在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效）</td>
</tr>
<tr>
<td>Shift+Enter</td>
<td>在当前行的下面插入新行，并移动光标到新行</td>
</tr>
<tr>
<td>Ctrl(Command)+J</td>
<td>自动代码</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+T</td>
<td>把选中的代码放在 <code>try{}</code> 、<code>if{}</code> 、 <code>else{}</code> 里</td>
</tr>
<tr>
<td>Shift+Alt(Option)+Insert</td>
<td>竖编辑模式</td>
</tr>
<tr>
<td>Ctrl(Command)+ <code>/</code></td>
<td>注释 <code>//</code></td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+ <code>/</code></td>
<td>注释 <code>/*…*/</code></td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+J</td>
<td>合并成一行</td>
</tr>
<tr>
<td>F2/Shift+F2</td>
<td>跳转到下/上一个错误语句处</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Back</td>
<td>跳转到上次编辑的地方</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Space</td>
<td>类名自动完成</td>
</tr>
<tr>
<td>Shift+Alt(Option)+Up/Down</td>
<td>内容向上/下移动</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Up/Down</td>
<td>语句向上/下移动</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+U</td>
<td>大小写切换</td>
</tr>
<tr>
<td>Tab</td>
<td>代码标签输入完成后，按 <code>Tab</code>，生成代码</td>
</tr>
<tr>
<td>Ctrl(Command)+Backspace</td>
<td>按单词删除</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Enter</td>
<td>语句完成</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+J</td>
<td>用动态模板环绕</td>
</tr>
</tbody>
</table>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl(Command)+F12</td>
<td>显示当前文件的结构</td>
</tr>
<tr>
<td>Ctrl(Command)+H</td>
<td>显示类继承结构图</td>
</tr>
<tr>
<td>Ctrl(Command)+Q</td>
<td>显示注释文档</td>
</tr>
<tr>
<td>Ctrl(Command)+P</td>
<td>方法参数提示</td>
</tr>
<tr>
<td>Ctrl(Command)+U</td>
<td>打开当前类的父类或者实现的接口</td>
</tr>
<tr>
<td>Alt(Option)+Left/Right</td>
<td>切换代码视图</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Left/Right</td>
<td>返回上次编辑的位置</td>
</tr>
<tr>
<td>Alt(Option)+Up/Down</td>
<td>在方法间快速移动定位</td>
</tr>
<tr>
<td>Ctrl(Command)+B</td>
<td>快速打开光标处的类或方法</td>
</tr>
<tr>
<td>Ctrl(Command)+W</td>
<td>选中代码，连续按会有其他效果</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+W</td>
<td>取消选择光标所在词</td>
</tr>
<tr>
<td>Ctrl(Command)+ <code>-</code> / <code>+</code></td>
<td>折叠/展开代码</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+ <code>-</code> / <code>+</code></td>
<td>折叠/展开全部代码</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+<code>.</code></td>
<td>折叠/展开当前花括号中的代码</td>
</tr>
<tr>
<td>Ctrl(Command)+ <code>]</code> / <code>[</code></td>
<td>跳转到代码块结束/开始处</td>
</tr>
<tr>
<td>F2 或 Shift+F2</td>
<td>高亮错误或警告快速定位</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+C</td>
<td>复制路径</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Shift+C</td>
<td>复制引用，必须选择类名</td>
</tr>
<tr>
<td>Alt(Option)+Up/Down</td>
<td>在方法间快速移动定位</td>
</tr>
<tr>
<td>Shift+F1</td>
<td>要打开编辑器光标字符处使用的类或者方法 <code>Java</code> 文档的浏览器</td>
</tr>
<tr>
<td>Ctrl(Command)+G</td>
<td>定位行</td>
</tr>
</tbody>
</table>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl(Command)+F</td>
<td>在当前窗口查找文本</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+F</td>
<td>在指定环境下查找文本</td>
</tr>
<tr>
<td>F3</td>
<td>向下查找关键字出现位置</td>
</tr>
<tr>
<td>Shift+F3</td>
<td>向上一个关键字出现位置</td>
</tr>
<tr>
<td>Ctrl(Command)+R</td>
<td>在当前窗口替换文本</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+R</td>
<td>在指定窗口替换文本</td>
</tr>
<tr>
<td>Ctrl(Command)+N</td>
<td>查找类</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+N</td>
<td>查找文件</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Alt(Option)+N</td>
<td>查找项目中的方法或变量</td>
</tr>
<tr>
<td>Ctrl(Command)+B</td>
<td>查找变量的来源</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+B</td>
<td>快速打开光标处的类或方法</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+B</td>
<td>跳转到类或方法实现处</td>
</tr>
<tr>
<td>Ctrl(Command)+E</td>
<td>最近打开的文件</td>
</tr>
<tr>
<td>Alt(Option)+F3</td>
<td>快速查找，效果和Ctrl(Command)+F相同</td>
</tr>
<tr>
<td>F4</td>
<td>跳转至定义变量的位置</td>
</tr>
<tr>
<td>Alt(Option)+F7</td>
<td>查询当前元素在工程中的引用</td>
</tr>
<tr>
<td>Ctrl(Command)+F7</td>
<td>查询当前元素在当前文件中的引用，然后按 <code>F3</code> 可以选择</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+F7</td>
<td>选中查询当前元素在工程中的引用</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+F7</td>
<td>高亮显示匹配的字符，按 <code>Esc</code> 高亮消失</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+F7</td>
<td>查找某个方法的所有调用地方</td>
</tr>
<tr>
<td>Ctrl(Command)+Shift+Alt(Option)+N</td>
<td>查找类中的方法或变量</td>
</tr>
<tr>
<td><em>Ctrl(Command)+Shift+O</em></td>
<td><em>弹出显示查找内容</em></td>
</tr>
<tr>
<td><em>Ctrl(Command)+Alt(Option)+Up/Down</em></td>
<td><em>快速跳转搜索结果</em></td>
</tr>
<tr>
<td><em>Ctrl(Command)+Shift+S</em></td>
<td><em>高级搜索、搜索结构</em></td>
</tr>
</tbody>
</table>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>F5</td>
<td>复制</td>
</tr>
<tr>
<td>F6</td>
<td>移动</td>
</tr>
<tr>
<td>Alt(Option)+Delete</td>
<td>安全删除</td>
</tr>
<tr>
<td>Ctrl(Command)+U</td>
<td>转到父类</td>
</tr>
<tr>
<td>Ctrl(Command)+O</td>
<td>重写父类的方法</td>
</tr>
<tr>
<td>Ctrl(Command)+I</td>
<td>实现方法</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+N</td>
<td>内联</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Shift+T</td>
<td>弹出重构菜单</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重构-重命名</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+M</td>
<td>提取代码组成方法</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+C</td>
<td>将变量更改为常量</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+V</td>
<td>定义变量引用当前对象或者方法的返回值</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+F</td>
<td>将局部变量更改为类的成员变量</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+P</td>
<td>将变量更改为方法的参数</td>
</tr>
</tbody>
</table>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>F8</td>
<td>跳到下一步</td>
</tr>
<tr>
<td>Shift+F8</td>
<td>跳出函数、跳到下一个断点</td>
</tr>
<tr>
<td>Alt(Option)+Shift+F8</td>
<td>强制跳出函数</td>
</tr>
<tr>
<td>F7</td>
<td>进入代码</td>
</tr>
<tr>
<td>Shift+F7</td>
<td>智能进入代码</td>
</tr>
<tr>
<td>Alt(Option)+Shift+F7</td>
<td>强制进入代码</td>
</tr>
<tr>
<td>Alt(Option)+F9</td>
<td>运行至光标处</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+F9</td>
<td>强制运行至光标处</td>
</tr>
<tr>
<td>Ctrl(Command)+F2</td>
<td>停止运行</td>
</tr>
<tr>
<td>Alt(Option)+F8</td>
<td>计算变量值</td>
</tr>
</tbody>
</table>
<h2 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt(Option)+ <code>~</code></td>
<td><code>VCS</code> 操作菜单</td>
</tr>
<tr>
<td>Ctrl(Command)+K</td>
<td>提交更改</td>
</tr>
<tr>
<td>Ctrl(Command)+T</td>
<td>更新项目</td>
</tr>
<tr>
<td>Ctrl(Command)+Alt(Option)+Shift+D</td>
<td>显示变化</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始全面转向Android Studio开发了，经常要去查快捷键，索性汇总下，自己方便查找&lt;/p&gt;
&lt;h2 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h2&gt;&lt;table&gt;
&lt;thead
    
    </summary>
    
    
      <category term="AndroidStudio" scheme="http://alenpan.github.io/tags/AndroidStudio/"/>
    
      <category term="keymap" scheme="http://alenpan.github.io/tags/keymap/"/>
    
  </entry>
  
  <entry>
    <title>编译型语言、解释型语言、静态类型语言、动态类型语言概念与区别</title>
    <link href="http://alenpan.github.io/2017/01/07/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://alenpan.github.io/2017/01/07/编译型语言、解释型语言、静态类型语言、动态类型语言概念与区别/</id>
    <published>2017-01-07T07:14:51.000Z</published>
    <updated>2017-02-08T08:50:21.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h2><h3 id="1、编译型语言"><a href="#1、编译型语言" class="headerlink" title="1、编译型语言"></a>1、编译型语言</h3><p>需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。</p>
<ul>
<li>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。</li>
<li>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</li>
</ul>
<p>代表语言：<code>C</code>、<code>C++</code>、<code>Pascal</code>、<code>Object-C</code> 、<code>swift</code>。</p>
<h3 id="2、解释型语言"><a href="#2、解释型语言" class="headerlink" title="2、解释型语言"></a>2、解释型语言</h3><p>解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。</p>
<ul>
<li>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</li>
<li>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</li>
</ul>
<p>代表语言：<code>JavaScript</code>、<code>Python</code>、<code>Erlang</code>、<code>PHP</code>、<code>Perl</code>、<code>Ruby</code>。</p>
<h3 id="3、混合型语言"><a href="#3、混合型语言" class="headerlink" title="3、混合型语言"></a>3、混合型语言</h3><p>既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。</p>
<p>比如<code>C#</code>，<code>C#</code>在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。</p>
<p><code>Java</code>先生成字节码再在<code>Java</code>虚拟机中解释执行。</p>
<p>严格来说混合型语言属于解释型语言。<code>C#</code>更接近编译型语言。</p>
<h2 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a><strong>动态语言和静态语言</strong></h2><h3 id="1、动态语言"><a href="#1、动态语言" class="headerlink" title="1、动态语言"></a>1、动态语言</h3><p>是一类在<strong>运行时可以改变其结构的语言</strong>：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
<p>主要动态语言：<code>Object-C</code>、<code>C#</code>、<code>JavaScript</code>、<code>PHP</code>、<code>Python</code>、<code>Erlang</code>。</p>
<h3 id="2、静态语言"><a href="#2、静态语言" class="headerlink" title="2、静态语言"></a>2、静态语言</h3><p>与动态语言相对应的，<strong>运行时结构不可变的语言</strong>就是静态语言。</p>
<p>主要动态语言：<code>Java</code>、<code>C</code>、<code>C++</code>。</p>
<h3 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h3><p>很多人认为解释型语言都是动态语言，这个观点是错的！<code>Java</code>是解释型语言但是不是动态语言，<code>Java</code>不能在运行的时候改变自己结构。反之成立吗？动态语言都是解释型语言。也是错的！<code>Object-C</code>是编译型语言，但是他是动态语言。得益于特有的run time机制（准确说run time不是语法特性是运行时环境，这里不展开），OC代码是可以在运行的时候插入、替换方法的。</p>
<p><code>C#</code>也是动态语言，通过<code>C#</code>的反射机制可以动态的插入一段代码执行。</p>
<p> <code>Java</code>只能算是<strong>准动态语言</strong>，<code>Java</code>反射仅仅能够得到<code>Java</code>类（或对象）运行时的信息，而不能改变其行为和属性。</p>
<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a><strong>动态类型语言和静态类型语言</strong></h2><h3 id="1、动态类型语言"><a href="#1、动态类型语言" class="headerlink" title="1、动态类型语言"></a>1、动态类型语言</h3><p>很多网上资料把动态类型语言和动态语言混为一谈，简直是误人子弟。动态类型语言和动态语言是完全不同的两个概念。</p>
<p>动态类型语言是指在<strong>运行期间才去做数据类型检查的语言</strong>，说的是数据类型，动态语言说的是运行是改变结构，说的是代码结构。</p>
<p>动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。</p>
<p>主要语言：<code>Python</code>、<code>Ruby</code>、<code>Erlang</code>、<code>JavaScript</code>、<code>swift</code>、<code>PHP</code>、<code>Perl</code>。</p>
<h3 id="2、静态类型语言"><a href="#2、静态类型语言" class="headerlink" title="2、静态类型语言"></a>2、静态类型语言</h3><p>静态语言的数据类型是在编译其间确定的或者说运行之前确定的，<strong>编写代码的时候要明确确定变量的数据类型</strong>。</p>
<p>主要语言：<code>C</code>、<code>C++</code>、<code>C#</code>、<code>Java</code>、<code>Object-C</code>。</p>
<h3 id="3、注意-1"><a href="#3、注意-1" class="headerlink" title="3、注意"></a>3、注意</h3><p>相当一部分程序员，也包括曾经的我，认为解释型语言都是动态类型语言，编译型语言都是静态类型语言。这个也是错的。swift是编译型语言但是它也是动态类型语言。C#和Java是解释型语言也是静态类型语言。</p>
<h2 id="强类型语言和弱类型语言"><a href="#强类型语言和弱类型语言" class="headerlink" title="强类型语言和弱类型语言"></a>强类型语言和弱类型语言</h2><h3 id="1、强类型语言"><a href="#1、强类型语言" class="headerlink" title="1、强类型语言"></a>1、强类型语言</h3><p>强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。</p>
<p>主要语言：<code>Java</code>、<code>C#</code>、<code>Python</code>、<code>Object-C</code>、<code>Ruby</code></p>
<h3 id="2、弱类型语言"><a href="#2、弱类型语言" class="headerlink" title="2、弱类型语言"></a>2、弱类型语言</h3><p><strong>数据类型可以被忽略，一个变量可以赋不同数据类型的值</strong>。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。</p>
<p>主要语言：<code>JavaScript</code>、<code>PHP</code>、<code>C</code>、<code>C++</code>（<code>C</code>和<code>C++</code>有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）。</p>
<h3 id="3、注意-2"><a href="#3、注意-2" class="headerlink" title="3、注意"></a>3、注意</h3><p>一个语言是不是强类型语言和是不是动态类型语言也没有必然联系。<code>Python</code>是动态类型语言，是强类型语言。<code>JavaScript</code>是动态类型语言，是弱类型语言。<code>Java</code>是静态类型语言，是强类型语言。</p>
<p>转载自：<a href="http://www.cnblogs.com/zy1987/p/3784753.html" target="_blank" rel="external">http://www.cnblogs.com/zy1987/p/3784753.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译型语言和解释型语言&quot;&gt;&lt;a href=&quot;#编译型语言和解释型语言&quot; class=&quot;headerlink&quot; title=&quot;编译型语言和解释型语言&quot;&gt;&lt;/a&gt;编译型语言和解释型语言&lt;/h2&gt;&lt;h3 id=&quot;1、编译型语言&quot;&gt;&lt;a href=&quot;#1、编译型语言&quot; c
    
    </summary>
    
    
      <category term="基础概念" scheme="http://alenpan.github.io/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题解析（1）</title>
    <link href="http://alenpan.github.io/2017/01/05/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>http://alenpan.github.io/2017/01/05/Java面试题之抽象类是否可继承实体类/</id>
    <published>2017-01-05T09:33:47.000Z</published>
    <updated>2017-02-08T08:50:21.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类是否可继承实体类-concrete-class-？"><a href="#抽象类是否可继承实体类-concrete-class-？" class="headerlink" title="抽象类是否可继承实体类(concrete class)？"></a>抽象类是否可继承实体类(concrete class)？</h2><p>网上的找到的面试题答案是：</p>
<blockquote>
<p>抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。</p>
</blockquote>
<p>答案很明确，可以继承。</p>
<p>其实从<code>Object</code>就是个实体类，<code>java</code>的API文档里，每个抽象类的条目里都明确写着直接或间接继承自<code>Object</code>，所以这点是没有疑问的。</p>
<p>关键在于这答案里所说的<strong>“前提是实体类必须有明确的构造函数”</strong>一句，是什么意思？</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>一般学习者会写的简单试验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>结果完全正常，编译通过。似乎和<strong>“实体类必须有明确的构造函数”</strong>没有关系。</p>
<p>这个问题涉及到两个个基础知识：</p>
<blockquote>
<ol>
<li><strong>所有的class都必须有一个构造方法（这里需要注意的是，抽象类也是拥有构造方法的，但抽象类与接口一样是不能创建实例的）</strong>，如果你没有在代码里声明构造方法，系统会自动给你生成一个公有无参的构造方法。而只要你自己声明了一个构造方法，无论有参无参，私有公有，系统就不再帮你生成默认无参构造器了。</li>
<li>所有的子类构造器都要求在第一行代码中调用父类构造器，如果不写，系统默认去调用父类的无参构造器。</li>
</ol>
</blockquote>
<p>所以，如果把系统默认配给的方法也算进去，<code>class A</code>的代码实际上是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>B继承A的时候，则是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要试验出这继承规则的内部情况，也很简单，在最上面那个简单试验代码里，加上个私有构造器，有参无参都行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，如基础知识(1) 中所说，系统不再给你默认无参构造器，B的构造器根据(2)中的规则去调用<code>super()</code>，却找不到A的无参构造器，所以导致<code>abstract class B extends A{}</code> 编译不能通过。（因为A中没有任何构造器可供子类调用，其实这个时候A只能够供内部类继承。）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，你应该了解了资料给的那句语焉不详的<strong>“实体类必须有明确的构造函数”</strong>的含义：</p>
<ol>
<li>没写构造器的，那是拥有默认无参公有构造函数的，子类可以什么都不写，让默认构造器去调用它。这是最初那两行代码的情况。</li>
<li>写了子类可访问的无参构造器的，也是一样，子类里可以什么都不写，用默认机制调用。</li>
<li>写了有参构造器却没写无参构造器的，父类里没有子类可访问的无参构造器，子类必须在子类构造器里的第一句写明，调用父类有参构造器，并把参数传进去。</li>
<li>声明为<code>final</code>的类或者所有构造器都不在子类访问权限之内的类无法继承。</li>
</ol>
<p>其实只要是在类的继承中，无论抽象还是实体，都需要符合这个规则的。在这个继承试验中随时删掉或是加上<code>abstract</code>的前缀，结果都没有变化。个人觉得<strong>“实体类必须有明确的构造函数”</strong>一句实在是无法把这个情况表达清楚，所以广大求职者还是写得清楚些好。</p>
<p>我喜欢的写法是“<strong>可以继承，但是和实体类的继承一样，也要求父类可继承，并且拥有子类可访问到的构造器。</strong>” </p>
<p>转载自：<a href="http://blog.csdn.net/ckw1988/article/details/4639514" target="_blank" rel="external">http://blog.csdn.net/ckw1988/article/details/4639514</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类是否可继承实体类-concrete-class-？&quot;&gt;&lt;a href=&quot;#抽象类是否可继承实体类-concrete-class-？&quot; class=&quot;headerlink&quot; title=&quot;抽象类是否可继承实体类(concrete class)？&quot;&gt;&lt;/a&gt;抽象
    
    </summary>
    
    
      <category term="Java" scheme="http://alenpan.github.io/tags/Java/"/>
    
      <category term="Class" scheme="http://alenpan.github.io/tags/Class/"/>
    
      <category term="Article" scheme="http://alenpan.github.io/tags/Article/"/>
    
      <category term="面试" scheme="http://alenpan.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计六大原则（1）</title>
    <link href="http://alenpan.github.io/2017/01/05/Single-Responsibility-Principle/"/>
    <id>http://alenpan.github.io/2017/01/05/Single-Responsibility-Principle/</id>
    <published>2017-01-05T07:37:42.000Z</published>
    <updated>2017-02-08T08:50:21.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是SRP？"><a href="#什么是SRP？" class="headerlink" title="什么是SRP？"></a>什么是SRP？</h2><p>单一职责原则的英文名称是Single Responsibility Principle，简称SRP。</p>
<p>SRP 的原话解释是 ：</p>
<blockquote>
<p>There should never be more than one reason for a class to change. </p>
</blockquote>
<p><strong>一个类或者模块应该有且只有一个改变的原因。</strong> 顾名思义，就是要求一个接口或类只有一个职责，它就负责一件事情。</p>
<h2 id="为什么要遵守SRP原则？"><a href="#为什么要遵守SRP原则？" class="headerlink" title="为什么要遵守SRP原则？"></a>为什么要遵守SRP原则？</h2><blockquote>
<p>When a class has more than one responsibility, there are also more triggers and reasons to change that class. A responsibility is the same as “a reason for change” in this context.</p>
</blockquote>
<p>因为每一个职责都是变化的因子，当需求变化时，该变化通常反映为类的职责的变化。<br>如果一个类承担了多于一个的职责，那么就意味着引起它的变化的原因会有多个，等同于把这些职责耦合在了一起。<br>一个职责的变化可能会抑制到该类完成其他职责的能力，这样的耦合会导致脆弱的设计。</p>
<p><strong>在设计类或接口时，如果能够遵守SRP原则，则会带来以下优点：</strong></p>
<ol>
<li><strong>类的复杂性降低：</strong>每个类或接口都只定义单一的职责，定义清晰明确</li>
<li><strong>可读性提高：</strong>定义清晰明确，自然带来较高的代码可读性</li>
<li><strong>可维护性提高：</strong>代码可读性提高，意味着更容易理解；单一职责使得类之间的耦合性较低，更改也会较为容易</li>
<li><strong>扩展性更好：</strong>当需要扩展新的职责时，只需要定义新的接口和新的实现即可</li>
</ol>
<h2 id="如何遵守SRP原则？"><a href="#如何遵守SRP原则？" class="headerlink" title="如何遵守SRP原则？"></a>如何遵守SRP原则？</h2><blockquote>
<p>Separating responsibility can be done by defining for every responsibility a class or an interface.</p>
</blockquote>
<p><strong>通过为每一项职责定义类或接口来实现职责分离。</strong> </p>
<p>另外，单一职责不仅适用于接口、类，还适用于方法。</p>
<h2 id="SRP原则的难点"><a href="#SRP原则的难点" class="headerlink" title="SRP原则的难点"></a>SRP原则的难点</h2><p>SRP原则堪称是SOLID原则（SOLID原则是SRP单一职责原则、OCP开闭原则、LSP里氏代换原则 、ISP接口隔离原则 、DIP依赖倒置原则 四个原则的第一个字母简称，如今还多了一个依赖注入DI。）里面最简单的一个原则，但也可以说是最难的一个。</p>
<p>它的“简单”之处在于它很容易被理解，“困难”之处在于很多人在软件设计过程中，很难真正地抓住关键点。</p>
<p>职责没有一个量化的标准，并且受非常多因素的制约，现实中实现起来会有困难。<strong>职责单一是相对的，每个人看事情的角度，对业务的理解程度是不尽相同的，这导致了人们对职责的定义和细化程度的差异性。</strong>同样一个业务，有些人从角度A出发，在对业务提炼归纳总结后，得出三项职责：J、K、L。而有些人则从角度B出发，归纳总结出两项职责：X、Y。</p>
<p>在设计接口时，这两人自然而然地会设计出不同的接口，两人设计的接口个数和表达的语义也各不相同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原则就像基准线，在设计类和接口时，我们应该尽量遵守基准线，而不是死守基准线，在设计时不应死板地依照原则进行设计。这就好比开车，司机的视线应该始终保持在正前方，如果沿着公路上的线开车而忽视了前方的交通情况，可能会引发交通事故。</p>
<p>对于单一职责原则，我的建议是<strong>接口一定要做到单一职责，类设计尽量只有一个原因引起变化</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是SRP？&quot;&gt;&lt;a href=&quot;#什么是SRP？&quot; class=&quot;headerlink&quot; title=&quot;什么是SRP？&quot;&gt;&lt;/a&gt;什么是SRP？&lt;/h2&gt;&lt;p&gt;单一职责原则的英文名称是Single Responsibility Principle，简称SRP。
    
    </summary>
    
    
      <category term="设计模式" scheme="http://alenpan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="http://alenpan.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>みっちりねこマーチ</title>
    <link href="http://alenpan.github.io/2017/01/02/Cat-Band-Music/"/>
    <id>http://alenpan.github.io/2017/01/02/Cat-Band-Music/</id>
    <published>2017-01-02T09:30:01.000Z</published>
    <updated>2017-02-08T08:50:21.220Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//www.youtube.com/embed/lAIGb1lfpBw" frameborder="0" allowfullscreen></iframe></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//www.youtube.com/embed/lAIGb1lfpBw&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Cat" scheme="http://alenpan.github.io/tags/Cat/"/>
    
      <category term="Cute" scheme="http://alenpan.github.io/tags/Cute/"/>
    
      <category term="Music" scheme="http://alenpan.github.io/tags/Music/"/>
    
      <category term="Video" scheme="http://alenpan.github.io/tags/Video/"/>
    
  </entry>
  
</feed>
